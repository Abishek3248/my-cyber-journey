# Metaspoilt Introduction

## Introduction
- Metasploit is the most widely used exploitation framework. Metasploit is a powerful tool that can support all phases of a penetration testing engagement, from information gathering to post-exploitation.
**Metasploit has two main versions:**
  - Metasploit Pro: The commercial version that facilitates the automation and management of tasks. This version has a graphical user interface (GUI).
  - Metasploit Framework: The open-source version that works from the command line. This room will focus on this version, installed on the AttackBox and most commonly used penetration testing Linux distributions.
- The Metasploit Framework is a set of tools that allow information gathering, scanning, exploitation, exploit development, post-exploitation, and more. While the primary usage of the Metasploit Framework focuses on the penetration testing domain, it is also useful for vulnerability research and exploit development.
**Main Components:**
  - msfconsole: The main command-line interface.
  - Modules: supporting modules such as exploits, scanners, payloads, etc.
  - Tools: Stand-alone tools that will help vulnerability research, vulnerability assessment, or penetration testing. Some of these tools are msfvenom, pattern_create and pattern_offset. We will cover msfvenom within this module, but pattern_create and pattern_offset are tools useful in exploit development which is beyond the scope of this module.


## Main Components of Metasploit

### Concepts Learned
- msfconsole is the primary interface to load and run modules.
- Modules = self-contained tools: auxiliary, exploits, payloads, encoders, evasion, nops, post.
- Payload types: adapters, singles (inline), stagers, stages — staged vs inline changes delivery and size.
- Naming hint: underscores (_) usually mean inline/single; slashes (/) usually mean staged.
- Modules live under the framework modules directory (AttackBox path: /opt/metasploit-framework/embedded/framework/modules).

### Explanation
- Exploit: code that takes advantage of a vulnerability to gain code execution or disclosure on a target.
- Payload: the code executed after exploitation — examples: reverse shell, add user, run command, or a staged downloader + larger implant.
- Auxiliary modules are for non-exploit tasks (scanning, service enumeration, brute-force, fuzzing) and are for reconnaissance and preparation.
**Payload structure:**
  - Adapters wrap a payload for a delivery method (e.g., PowerShell wrapper).
  - Singles (inline) are self-contained payloads that run immediately without fetching extra bits.
  - Stagers bootstrap a small connection then download stages; stages are the larger payloads pulled in by stagers. Use stagers for large implants or constrained networks.
  - Encoders slightly modify payload byte-patterns to avoid signature matches; evasion modules attempt more advanced AV/defense bypasses — neither is guaranteed to work against modern protections.
  - NOPs are padding bytes (e.g., x86 0x90) used to normalize payload alignment/size.
  - Post modules run after compromise to automate enumeration, credential harvesting, persistence, and lateral movement preparation.

### Notes
- Start with auxiliary modules for discovery — scanning first reduces blind exploitation risk.
- Inspect module files (under modules/) to see required options and platform targets before running.
- Choose inline payloads for reliability/simple tests; choose staged payloads when payload size or stealth matters.
- Always test encoders/evasion in a lab; do not assume they bypass enterprise defenses.
- While documenting a module, record: module path/name, target platform, required options, chosen payload, and what happened when run (session type, errors, stability).


## Msfconsole

### Concepts Learned
- msfconsole is the main Metasploit interface for loading modules, setting options, and running attacks.
- Contextual workflow: use a module changes prompt/context; options set inside a context apply only to that module.
- Key commands: search, use, show options, set, run/exploit, info, back, help, history.
- Modules are categorized (auxiliary, exploit, payload, post, encoder, evasion, nops) and searchable by type, platform, CVE, etc.
- Module ranking indicates reliability but not guaranteed success; test carefully.

### Explanation
- Launching: start msfconsole (msf6 >) to get an interactive shell that accepts Metasploit commands and many normal shell execs (ls, ping, clear).
- Contexts: use <module> switches the console into that module’s context (prompt shows module path). Settings you set in that context live there until you back or change modules.
**Inspecting modules:**
  - info <module> shows authors, targets, description, references, and required options.
  - show options lists module-specific settings (RHOSTS, RPORT, LHOST, PAYLOAD, etc.).
  - show payloads lists compatible payloads for the chosen exploit.
  - Searching: search <term> accepts filters (type:, platform:, cve:) so you can find relevant modules quickly and use results by index or full path.
  - Running modules: set required options (e.g., RHOSTS, LHOST), choose a payload if needed, then run or exploit. Use back to leave module context.
  - Help & ergonomics: help <command> for usage; tab-completion speeds up typing; history shows past commands. msfconsole does not support all shell features (e.g., output redirection).

### Notes
- Always run show options after use to see what must be set (RHOSTS, SESSION, etc.).
- Use search with filters (e.g., search cve:2017 type:exploit) to narrow results.
- Prefer show payloads to pick a payload matching architecture and staged vs inline needs. Inline payloads often show with _ in name; staged payloads use / in path.
- Remember module ranks are guidance — low-ranked exploits can still work and high-ranked ones can crash targets.
- Save reproducible steps: module path, options you set, payload chosen, and any errors or session behavior observed.
- If you need to run OS commands from msfconsole, prefix with exec: or just type the command — limited support compared to a full shell.
- Use info <module> for deep details (targets, disclosure, notes, references) before running potentially destructive exploits.


## Working with Modules

### Concepts Learned
- Modules require parameters (set with set, unset, setg, unsetg).
- show options lists required and optional parameters for the current module.
**Different Metasploit prompts exist:**
  - root@...# → system shell, not Metasploit.
  - msf6 > → msfconsole, no module context.
  - msf6 exploit(...) > → inside a module, can set/run.
  - meterpreter > → Meterpreter payload prompt.
  - C:\Windows\system32> → shell on target machine.
**Common parameters:**
  - RHOSTS → target IP(s)/range/file.
  - RPORT → target port (default often set).
  - PAYLOAD → exploit payload.
  - LHOST → attacker IP.
  - LPORT → attacker listening port.
  - SESSION → session ID for post-exploitation.
-setg makes parameters global across modules; unset all clears all set values.
**Running modules:**
  - exploit or run launches the module.
  - exploit -z runs and backgrounds the session automatically.
  - Some modules support check → tests vulnerability without exploiting.
**Sessions:**
  - background or CTRL+Z sends session to background.
  - sessions lists active sessions.
  - sessions -i <id> interacts with a session.

### Explanation
- After using a module (use exploit/...), always run show options to confirm what needs setting. Some values are pre-filled (e.g., RPORT=80 or 445) but must be verified.
- Use set to configure parameters, unset to clear, unset all to flush everything, setg for global persistence across modules, and unsetg to remove global values.
- The prompt context changes depending on where you are: msfconsole, inside a module, meterpreter, or target shell. Always check the prompt before running commands.
- Sessions represent active connections to exploited targets. They can be listed, backgrounded, or interacted with as needed.

### Notes
- Always check prompt type to avoid typing Metasploit commands in the wrong context.
- Validate pre-populated ports (e.g., RPORT 80 vs 8080).
- Use exploit -z when you want to launch and keep working without locking into the session.
- Keep track of session IDs when multiple shells or Meterpreters are open.
- setg is useful for repetitive settings like RHOSTS or LHOST across multiple modules.


## KeyTakeaways
- Metasploit uses a **modular structure**: exploits, payloads, auxiliaries, encoders, nops, and post modules.  
- `use <module>` enters a specific module context; always run `show options` to view required parameters.  
- **Options**:  
  - `set` → sets value for current module  
  - `setg` → sets global value across all modules  
  - `unset` / `unset all` → remove parameter(s)  
- **Payloads**: decide how you interact with the target (e.g., reverse shell, meterpreter). Use `show payloads` to see compatible ones.  
- **Running modules**: `exploit` or `run` starts the attack or action; add flags like `-z` to background sessions.  
- **Sessions**: use `sessions`, `sessions -i <id>`, and `background` to manage compromised hosts.  
- **Search & Info**: `search <term>` finds modules, `info` provides detailed metadata.  
- Good practice: set persistent values with `setg` (like `LHOST`), check with `check` before exploit, and always confirm target compatibility.  
